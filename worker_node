#include "FS.h"
#include "SPIFFS.h"
#include "LoRaWan_APP.h"
#include "Arduino.h"

// ========== Device ID (Set differently for each node) ==========
const char* DEVICE_ID = "NODE_A";  // or "NODE_B"

// ========== Sensor Definition ==========
enum SensorType {
  SENSOR_NONE,
  SENSOR_TEMPERATURE,
  SENSOR_ILLUMINANCE,
  SENSOR_HUMIDITY
};

SensorType currentSensor = SENSOR_TEMPERATURE;

// ========== LoRa Configuration ==========
char txpacket[64];
bool lora_idle = true;
double txNumber = 0;

static RadioEvents_t RadioEvents;
void OnTxDone(void);
void OnTxTimeout(void);
void OnRxDone(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr);

// ========== Transmission Timer ==========
unsigned long lastSendTime = 0;
unsigned long nextSendInterval = 10000;

// ========== Setup ==========
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.printf("üì¶ System initializing... (%s)\n", DEVICE_ID);

  if (!SPIFFS.begin(true)) {
    Serial.println("‚ùå Failed to initialize SPIFFS");
    while (1);
  }

  Mcu.begin(HELTEC_BOARD, SLOW_CLK_TPYE);
  RadioEvents.TxDone = OnTxDone;
  RadioEvents.TxTimeout = OnTxTimeout;
  RadioEvents.RxDone = OnRxDone;
  Radio.Init(&RadioEvents);

  Radio.SetChannel(915000000);
  Radio.SetTxConfig(MODEM_LORA, 5, 0, 0, 7, 1, 8,
                    false, false, 0, 0, false, 3000);
  Radio.SetRxConfig(MODEM_LORA, 0, 7, 1, 0, 8, 0,
                    false, 0, true, 0, 0, false, true);

  Serial.println("‚úÖ System ready");
  updateDetectionTarget(SENSOR_TEMPERATURE);
  Radio.Rx(0);  // Always start in RX mode
}

// ========== Main Loop ==========
void loop() {
  Radio.IrqProcess();

  // Switch sensor via serial input
  if (Serial.available()) {
    char cmd = Serial.read();
    if (cmd != '\n' && cmd != '\r') {
      switch (cmd) {
        case 't': updateDetectionTarget(SENSOR_TEMPERATURE); break;
        case 'l': updateDetectionTarget(SENSOR_ILLUMINANCE); break;
        case 'h': updateDetectionTarget(SENSOR_HUMIDITY); break;
        case 'n': updateDetectionTarget(SENSOR_NONE); break;
        default: Serial.println("‚ùì Unknown command"); break;
      }
    }
  }

  // Transmit at irregular intervals
  if (millis() - lastSendTime >= nextSendInterval && lora_idle) {
    delay(random(100, 500));  // Random delay to avoid collisions

    String data = readFromCurrentSensor();
    snprintf(txpacket, sizeof(txpacket), "[%s|%0.0f] %s", DEVICE_ID, ++txNumber, data.c_str());
    Serial.printf("üì§ Sending: %s\n", txpacket);

    Radio.Send((uint8_t*)txpacket, strlen(txpacket));
    lora_idle = false;
    lastSendTime = millis();
    nextSendInterval = random(8000, 15000);  // Next interval: 8~15 seconds
  }
}

// ========== Sensor Logic ==========
void updateDetectionTarget(SensorType target) {
  deactivateAllSensors();
  currentSensor = target;

  switch (target) {
    case SENSOR_TEMPERATURE: Serial.println("üå°Ô∏è Temp sensor activated"); break;
    case SENSOR_ILLUMINANCE: Serial.println("üí° Light sensor activated"); break;
    case SENSOR_HUMIDITY:    Serial.println("üíß Humidity sensor activated"); break;
    default:                 Serial.println("‚ùå No valid sensor selected"); break;
  }
}

void deactivateAllSensors() {
  Serial.println("üîå All sensors deactivated");
}

String readFromCurrentSensor() {
  int value = random(0, 100);
  switch (currentSensor) {
    case SENSOR_TEMPERATURE: return "Temp: " + String(value) + "C";
    case SENSOR_ILLUMINANCE: return "Light: " + String(value) + "lx";
    case SENSOR_HUMIDITY:    return "Humidity: " + String(value) + "%";
    default: return "No active sensor";
  }
}

// ========== LoRa Event Handlers ==========
void OnTxDone() {
  Serial.println("‚úÖ LoRa TX done");
  Radio.Rx(0);
  lora_idle = true;
}

void OnTxTimeout() {
  Serial.println("‚è±Ô∏è LoRa TX timeout");
  Radio.Rx(0);
  lora_idle = true;
}

void OnRxDone(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr) {
  char rxBuf[64];
  memcpy(rxBuf, payload, size);
  rxBuf[size] = '\0';

  // Handle ACK
  if (strcmp(rxBuf, "ACK") == 0) {
    Serial.printf("üì• Received ACK | RSSI: %d\n", rssi);
    Radio.Rx(0);
    lora_idle = true;
    return;
  }

  // Ignore own packet
  if (strstr(rxBuf, DEVICE_ID) != nullptr) {
    Serial.println("üõë Skipping self-packet");
    Radio.Rx(0);
    lora_idle = true;
    return;
  }

  // Parse message
  String message = String(rxBuf);
  int startIdx = message.indexOf('[');
  int midIdx = message.indexOf('|');
  int endIdx = message.indexOf(']');

  if (startIdx != -1 && midIdx != -1 && endIdx != -1) {
    String senderId = message.substring(startIdx + 1, midIdx);
    String msgNumber = message.substring(midIdx + 1, endIdx);
    String content = message.substring(endIdx + 2);
    Serial.printf("üì• From %s | Msg #%s | Content: %s | RSSI: %d\n",
                  senderId.c_str(), msgNumber.c_str(), content.c_str(), rssi);
  } else {
    Serial.printf("üì• Unknown Format: %s | RSSI: %d\n", rxBuf, rssi);
  }

  // Sensor control
  if (strstr(rxBuf, "Temp") != nullptr) updateDetectionTarget(SENSOR_TEMPERATURE);
  else if (strstr(rxBuf, "Light") != nullptr) updateDetectionTarget(SENSOR_ILLUMINANCE);
  else if (strstr(rxBuf, "Humidity") != nullptr) updateDetectionTarget(SENSOR_HUMIDITY);
  else if (strstr(rxBuf, "None") != nullptr) updateDetectionTarget(SENSOR_NONE);

  // Send ACK response
  Serial.println("üì® Sending ACK...");
  Radio.Send((uint8_t*)"ACK", 3);
  delay(100);
  Radio.Rx(0);
  lora_idle = true;
}
